# 2장 SQL 튜닝 용어를 직관적으로 이해하기

### 2.2.4 조인 연산방식 용어

<br>

- **Join**
    - 필요한 데이터끼리 결합할 때 사용하는 방식
    - 분리된 데이터 간의 공통된 정보, 즉 동일한 열값 또는 키값 기준으로 데이터를 논리적으로 연결 가능

<br>

#### 내부 조인
- inner join
- 교집합에 해당하는 방식, `양쪽에 모두 존재하는 데이터만 반환`
```sql
# 명시적 조인 사용 (ON 이용)
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생 JOIN 지도교수 ON 학생.학번 = 지도교수.학번

# 암시적 조인 사용
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생
WHERE 학생.학번 = 지도교수.학번
```

<br>

#### 왼쪽 외부 조인
- left outer join
- `왼쪽 테이블 기준으로 오른쪽 테이블과 조인` 수행하지만,
- 조인 조건이 일치하지 않더라도 왼쪽 테이블의 결과는 최종 결과에 포함
```sql
# LEFT OUTER JOIN
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생 LEFT OUTER JOIN 지도교수 ON 학생.학번 = 지도교수.학번
```

<br>

#### 오른쪽 외부 조인
- right outer join
- `오른쪽 테이블 기준으로 왼쪽 테이블과 조인`을 하지만,
- 조인 조건이 일치하지 않더라도 오른쪽 테이블의 결과는 최종 결과에 포함
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생 RIGHT OUTER JOIN 지도교수 ON 학생.학번 = 지도교수.학번
```

> 사람의 인지 특성상 `보통 왼쪽 -> 오른쪽을 정방향`으로 인식
> 즉, 쿼리에서 왼쪽에 위치한 테이블 기준으로 조인을 수행하는 LEFT OUTER JOIN을 주로 사용
>
> 따라서, 오른쪽 외부 조인 쿼리문을 왼쪽 외부 조인 쿼리문으로 변경해서 일관성있게 SQL문을 작성해야함
> 유지보수나 관리 편의상 측면에서 유리함

<br>

#### 교차 조인
- cross join
- 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 찾아내어 반환
- 모든 경우의 수가 출력 대상, 내부 조인에 비해 수백 배 이상 많은 데이터 양을 얻을 수 있음
    - 조인 연산 과정의 시간적, 공간적 리소스 점유 측면에서 오버헤드 발생 주의
```sql
# 명시적 교차 조인
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생 CROSS JOIN 지도교수

# 암시적 교차 조인
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생, 지도교수
```

<br>

#### 자연 조인
- natural join
- 2개 테이블에 동일한 열명이 있을 때 조인 조건절을 따로 작성하지 않아도 자동으로 조인 수행
- 조인이 제대로 성사되면 내부 조인과 동일한 결과 출력
- 만약, 동일한 열명이 없다면 발생 가능한 경우의 수를 모두 조합하는 교차 조인으로 수행됨
```sql
# 조인 조건절을 알아서 찾아주므로 직접적인 조인 조건문 작성 x
SELECT 학생.*, 지도교수.*
FROM 학생 NATURAL JOIN 지도교수
```

<br>

### 2.2.5 조인 알고리즘 용어
- 다수의 테이블에서 조인을 수행할 때는 동시에 여러 개의 테이블에 접근할 수 없는 만큼 접근 우선순위를 정하게 됨
- 이때, 테이블에 접근하는 선후 관계에 따라 드라이빙 테이블과 드리븐 테이블 용어로 구분
- 또한 각 테이블에 접근해 조인을 수행하는 여러가지 방식의 알고리즘 존재

#### 드라이빙 테이블과 드리븐 테이블
- **드라이빙 테이블**
    - Driving Table
    - 먼저 접근하는 테이블 (outer table)

<br>

- **드리븐 테이블**
    - Driven Table
    - 드라이빙 테이블의 검색 결과를 통해 뒤늦게 데이터를 검색하는 테이블 (inner table)

<br>

- **정리**
    - 드라이빙 테이블에서 많은 건수가 반환되면 해당 결과를 가지고 드리븐 테이블에 접근하게 되기 때문에 드라이빙 테이블을 무엇으로 선정할지는 매우 중요한 문제
    - 가능하면 적은 결과가 반환될 것으로 예상되는 테이블을 드라이빙 테이블로 선정하고, 조인 조건절의 열이 인덱스로 설정되도록 구성해야함

<br>

#### 조인 알고리즘
- **중첩 루프 조인**
    - Nested Loop join (NL 조인)
    - 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며
    - 최종적으로는 양쪽 테이블에 공통된 데이터를 출력
    
    <br>

    - 인덱스가 없는 경우 조인을 하기 위해 드라이빙 테이블 데이터 하나 마다 드리븐 테이블 전체를 검색해야함 (너무 오래걸림)
    - `만약 인덱스를 잘 설정해 놓는다면 시간을 줄일 수 있음`
        - 인덱스는 인덱스로 정의된 열 기준으로 순차 정렬되지만,
        - 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 랜덤 액세스가 발생
        - 따라서, 랜덤 액세스를 줄일 수 있도록 데이터의 액세스 범위를 좁히는 방향으로 인덱스를 설계하고 조건절을 작성해야함
    > 이때, 랜덤 액세스를 유발하는 인덱스는 기본키가 아닌 비교유 인덱스임
    > 기본 키는 클러스터형 인덱스이므로 기본 키의 순서대로 테이블의 데이터가 적재되어 있어 조회 효율이 매우 높음

<br>

- **블록 중첩 루프 조인**
    - Block Nested Loop join (BNL 조인)
    - 드라이빙 테이블은 인덱스가 있지만, 드리븐 테이블은 인덱스가 없는 경우
        - 중첩 루프 조인을 수행
        - 인덱스가 없는 드리븐 테이블에 대해 매번 전체 데이터를 비효율적으로 검색해야함
    - 이때, `중첩 루프 조인의 효율을 높이고자 등장`한 것이 BNL 조인
        - 드라이빙 테이블에 대해 `조인 버퍼(join buffer)`라는 개념을 도입하여 조인 성능을 향상
    
    <br>

    - 정리
        - 드라이빙 테이블에서 인덱스롤 통해 데이터 검색
        - 검색한 데이터를 조인 버퍼에 가득찰 때까지 적재 해놓음
        - 이후, 조인 버퍼와 드리븐 테이블의 데이터를 비교
        - 이렇게하면 조인 버퍼의 데이터들과 `드리븐 테이블의 한번의 테이블 풀 스캔`으로 원하는 데이터 모두 찾기 가능

<br>

- **배치 키 액세스 조인**
    - Batched Key Access Join (BKA 조인)
    - 랜덤 액세스의 단점을 해결하고자 접근할 데이터를 미리 예상하고 가져오는데 착안한 조인 알고리즘
        - 랜덤 액세스의 단점
            - 액세스할 데이터 범위가 넓다면 비효율적임
    
    <br>

    - 드라이빙 테이블의 조인 버퍼 개념을 그대로 사용
    - 그리고 드리븐 테이블에 필요한 데이터를 미리 예측하고 정렬된 상태로 담는 랜덤 버퍼의 개념 도입
        - `MRR`
            - 다중 범위 읽기 (Multi Ranged Read)
            - 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능
    - 즉, `미리 예측된 데이터를 가져와 정렬된 상태에서 랜덤 버퍼에 담기 때문에` 드리븐 테이블에 대해 랜덤액세스가 아닌 `시퀀셜 액세스를 수행`하는 방식

<br>

- **해시 조인**
    - Hash Join
    - 선후 관계를 두고 조인을 수행하는 중첩 루프 조인 방식과 달리,
    - 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행
    - 해시 값으로 내부 조인을 수행한 결과는 `조인 버퍼에 저장`되므로 조인 열의 인덱스를 필수로 요구하지 않아도 됨

<br>

### 2.3 개념적인 튜닝 용어
- 쿼리 튜닝과 관련된 용어
    - 오브젝트들을 스캔하는 유형
    - 디스트 접근 방식

<br>

### 2.3.1 기초 용어

<br>

#### 오브젝트 스캔 유형
- 테이블 스캔
    - 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형
    - 테이블 풀 스캔
- 인덱스 스캔
    - 인덱스로 테이블 데이터를 찾아가는 유형
    - 인덱스 범위 스캔, 인덱스 풀 스캔, 인덱스 고유 스캔, 인덱스 루스 스캔, 인덱스 병합 스캔

<br>

- **테이블 풀 스캔**
    - table full scan
    - 인덱스를 거치지 않고 `테이블로 바로 직행하여 처음부터 끝까지 데이터를 훑어보는 방식`
    - WHERE 절의 조건문을 기준으로 활용할 인덱스가 없거나
    - 전체 데이터 대비 대량의 데이터가 필요한 경우
    - 처음부터 끝까지 데이터를 검색하므로 성능 측면에서는 부정적으로 해석됨

<br>

- **인덱스 범위 스캔**
    - index range scan
    - `인덱스를 범위 기준으로 스캔한 뒤 스캔 결과를 토대로 테이블의 데이터를 찾아가는 방식`
    - BETWEEN ~ AND 구문이나 <, >, LIKE 구문등에서 사용
    - 좁은 범위를 스캔할 때는 성능적으로 매우 효율적이지만, 넓은 범위를 스캔할 때는 비효율적인 방식임

<br>

- **인덱스 풀 스캔**
    - index full scan
    - `인덱스를 처음부터 끝까지 수행하는 방식`
    - 단, 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL문에서 수행됨
        - 인덱스라는 오브젝트의 전 영역을 모두 검색하는 방식인 만큼 검색 범위를 최대한 줄이는 방향으로 SQL 튜닝해야함

<br>

- **인덱스 고유 스캔**
    - index unique scan
    - `기본 키나 고유 인덱스로 테이블에 접근하는 방식`
    - 인덱스를 사용하는 스캔 방식 중 가장 효율적인 스캔 방법
    - WHERE 절에 = 조건으로 작성
    - 해당 조인 열이 기본 키 또는 고유 인덱스의 선두 열로 설정되었을 때 활용

<br>

- **인덱스 루스 스캔**
    - index loose scan
    - `인덱스의 필요한 부분들만 골라 스캔하는 방식`
    - 인덱스 범위 스캔처럼 넓은 범위 전부 접근하지 않고, WHERE 절 조건문 기준으로 필요한 데이터와 필요하지 않은 데이터를 구분한 뒤 불필요한 인덱스 키는 무시
    - GROUP BY 구문이나 MAX(), MIN() 함수가 포함되면 작동

<br>

- **인덱스 병합 스캔**
    - index merge scan
    - `테이블 내에 생성된 인덱스를 통합해서 스캔하는 방식`
    - 물리적으로 존재하는 개별 인덱스를 각각 수행하므로 인덱스에 접근하는 시간이 몇 배로 걸림
    - 따라서 별개로 생성된 인덱스들은 보통 하나의 인덱스로 통합하여 SQL 튜닝을 수행하거나, SQL 문 자체를 독립된 하나의 인덱스만 수행하도록 변경할 수 있음

<br>

#### 디스크 접근 방식
- MySQL은 원하는 데이터를 찾기 위해 데이터가 저장된 스토리지의 페이지(page)에 접근
    - Page
        - 데이터를 검색하는 최소 단위
        - 페이지 단위로 데이터를 읽고 쓰기를 수행할 수 있음
    - 시퀀셜 액세스
        - 서로 연결된 페이지를 차례대로 읽음
    - 랜덤 액세스
        - 여기저기 원하는 페이지를 임의로 열어보며 데이터를 읽음

<br>

- **시퀀셜 액세스**
    - Sequential Access
    - `물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식`
    - 보통 테이블 풀 스캔에서 활용
        - 테이블 풀 스캔일 때는 `인접한 페이지를 여러 개 읽는 다중 페이지 읽기(Multi page read) 방식`으로 수행됨
    - 데이터를 찾고자 이동하는 디스크 헤더(Disk Header)의 움직임을 최소화하여 직업 시간과 리소스 점유 비용을 줄일 수 있음

<br>

- **랜덤 액세스**
    - Random Access
    - `물리적으로 떨어진 페이지들에 임의로 접근하는 임의 접근 방식`
    - 페이지가 위치한 물리적인 위치를 고려하지 않고 접근
        - 디스크의 물리적인 움직임이 필요
        - 다중 페이지 읽기가 불가능하기 때문에, 데이터의 접근 수행 시간이 오래걸림
    - 따라서, 최소한의 페이지에 접근할 수 있도록 접근 범위를 줄이고 효율적인 인덱스를 활용할 수 있도록 튜닝해야함

<br>

#### 조건 유형
- SQL문의 WHERE 절 조건문 기준으로 데이터가 저장된 디스크에 접근
- 액세스 조건
    - 맨 처음 디스크에서 데이터를 검색하는 조건
- 필터 조건
    - 디스크에서 가져온 데이터에서 추가로 추출하거나 가공 및 연산하는 조건

<br>

- **액세스 조건**
    - `디스크에 있는 데이터에 어떻게 접근할 것인지`
    - WHERE 절 조건문으로 필요한 데이터만 골라 가져오는 방식은 테이블에 직접 접근할지, 인덱스를 어떻게 활용할지에 대한 문제
    - 그러나 SQL 문의 조건절에는 한계가 있음
        - 따라서, 옵티마이저는 WHERE 절의 특정 조건문을 이요해 소량의 데이터를 가져오고,
        - 인덱스를 통해 시간 낭비를 줄이는 조건절을 선택하여,
        - 스토리지 엔진의 데이터에 접근하고 MySQL 엔진으로 데이터를 가져옴

<br>

- **필터 조건**
    - 액세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로,
    - 추가로 `불필요한 데이터를 제거하거나 가공하는 조건`
    - 필터 조건에 따라 필터링할 데이터가 없다면 좋은 SQL 문
        - 그 이유는 스토리지 엔진에서 MySQL 엔진으로 데이터를 전달하는 오버헤드가 있는데, 필터 조건으로 제거될 데이터라면 스토리지 엔진의 데이터에 접근하는 과정에서 같이 제외되는 편이 성능적으로 효율적이기 때문

<br>

### 2.3.2 응용 용어
- **선택도**
    - Selectivity
    - `테이블의 특정 열을 기준으로 해당 열의 조건절에 따라 선택되는 데이터 비율`을 의미
    - 선택도가 높다
        - 해당 열에 중복되는 데이터가 많다
        - 조건절에 따라 대량의 데이터가 선택될 것
    - 선택도가 낮다
        - 해당 열에 중복되는 데이터가 적다
        - 조건절에 따라 매우 적은 양의 데이터가 선택됨

    <br>

    - 낮은 선택도가 오히려 대용량 데이터에서 원하는 데이터만 골라 내는 능력임
        - 낮은 선택도를 가지는 열은 데이터를 조회하는 SQL 문에서 원하는 데이터를 빨리 찾기 위한 인덱스 열을 생성할 때 주요 고려대상이 됨

<br>

- **카디널리티**
    - Cardinality
    - `하나의 데이터 유형으로 정의되는 데이터 행의 개수`
    - 전체 데이터에 접근한 뒤 출력될 것이라 예상되는 데이터 건수
    - 현업에서는 `전체 행에 대한 특정 열의 중복 수치를 나타내는 지표`로 자주 활용
    - 중복도가 높으면 카디널리티가 낮고, 중복도가 낮으면 카디널리티가 높다
        - 즉, 중복되지 않는 유일한 값일수록 카디널리티가 높음

<br>

- **힌트**
    - Hint
    - `데이터를 빨리 찾을 수 있게 추가 정보를 전달하는 것`
    - 항상 사용되는 것은 아님, 옵티마이저가 비효율적이라고 판단하면 사용되지 않음
    ```sql
    # USE INDEX를 통해서 좀 더 빨리 찾을 수 있도록 힌트를 줌
    SELECT 학번, 전공코드
    FROM 학생 USE INDEX(학생_IDX01)
    WHERE 이름 = '유재석';
    ```
    
    <br>

    - 주요 힌트
        - STRAIGHT_JOIN
            - FROM 절에 작성한 테이블 순으로 조인을 유도하는 힌트
        - USE INDEX
            - 특정 인덱스를 사용하도록 유도하는 힌트
        - FORCE INDEX
            - 특정 인덱스를 사용하도록 강하게 유도하는 힌트
        - IGNORE INDEX
            - 특정 인덱스를 사용하지 못하도록 유도하는 힌트

<br>

- **콜레이션**
    - Collation
    - `특정 문자셋으로 데이터베이스에 저장된 값을 비교하거나 정렬하는 작업의 규칙`

<br>

- **통계정보**
    - 옵티마이저는 통계정보에 기반을 두고 SQL 문의 실행계획을 수립
    - MySQL은 시스템 변수를 통해 활용할 통계정보의 수준을 정의할 수 있음
    - 통계정보의 최신성 유지 및 관리가 매우 중요

<br>

- **히스토그램**
    - Histgram
    - `테이블의 열값이 어떻게 분포되어 있는지를 확인하는 통계정보`
    - 옵티마이저가 실행 계획을 최적화하고자 참고하는 정보
    - MySQL 내부적으로는 높이균형 히스토그램 방식을 사용