# 2장

## 조인 연산방식 SQL 용어

:  데이터 결합에 관한 용어 설명

![IMG_5080.heic](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/606153b0-6944-40bf-9ec7-aed6da00abd0/IMG_5080.heic)

![IMG_5081.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/0e34fdc3-e9d8-4f3c-9aa4-4c61ff009f93/IMG_5081.jpeg)

-예제에 사용할 테이블

### 내부 조인

양쪽에 모두 존재하는 데이터만 반환

내부 조인을 명시적 조인으로 표현한 SQL문

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
	FROM 학생
	JOIN 지도교수
		ON 학생.학번 = 지도교수.학번
		
```

내부 조인을 암시적 조인으로 표현한 SQL문

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
	FROM 학생,지도교수
	WHERE 학생.학번 = 지도교수.학번
		
```

### 왼쪽 외부 조인

왼쪽 테이블.(먼저 작성된 테이블) 기준으로 오른쪽 테이블 (나중에 작성된 테이블) 과 조인을 수행

왼쪽 테이블의 결과는 조인 조건과 상관없이 항상 포함됨.

```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
	FROM 학생
	LEFT OUTER JOIN 지도교수
		ON 학생.학번 = 지도교수.학번
```

### 오른쪽 외부 조인

나중에 작성된 테이블 기준으로 왼쪽 테이블과 조인.

오른쪽 테이블의 결과는 조인 조건과 상관없이 항상 포함됨.

```sql
SELECT 지도교수.학번, 학생.이름 , 지도교수.교수명
	FROM 학생
	RIGHT OUTER JOIN 지도교수
		ON 학생.학번 = 지도교수.학번
```

### 오른쪽 외부조인을 왼쪽 외부조인으로 변경

순서만 바꾼것이므로 쉽게 변경 가능.

코드의 일관성 목적

```sql
SELECT *
	FROM B_TABLE
	RIGHT OUTER JOIN A_TABLE
		ON ...
		
/// 위 구문을

SELECT *
	FROM A_TABLE
	LEFT OUTER JOIN B_TABLE
		ON...

/// 이렇게 변경 가능
```

### 교차 조인

데카르트 곱 : 집합 내 모든 순서쌍의 교차

데이터 컬럼 내 모든 항목에 대해 모든 조합을 찾아내서 반환하는 것.

시,공간적 리소스 점유 측면에서 오버에드가 발생할수 있음

```sql
SELECT 학생.학번, 학생.이름 , 지도교수.학번 , 지도교수.교수명
	FROM 학생
	CROSS JOIN 지도교수
	
```

### 자연 조인

2개 테이블 내에서 동일한 열명이 있을때 조건을 작성하지 않아도 자동적으로 조인을 해주는 방식

작동하면 내부 조인과 동일한 결과를 얻음

동일한 열명이 없으면 교차 조인으로 수행됨.

일반적으로 잘 사용되지 않음

```sql
SELECT 학생.* , 지도교수.*
	FROM 학생
	NUTURAL JOIN 지도교수
	
```

## 조인 알고리즘 용어

다수의 테이블에서 조인이 수행될 시, 동시에 여러개 테이블에서 접근할수 없으므로 테이블마다 우선순위가 설정됨.

이때 선후관계에 따라 드라이빙 테이블과 드리븐 테이블로 구분됨

### 드라이빙 테이블과 드리븐 테이블

드라이빙 테이블 : 탐색 시 먼저 접근되는 테이블. 

드리븐 테이블 : 드라이빙 테이블의 검색 결과를 통해서 접근되는 테이블

드라이빙 테이블에서 많은 결과가 반환되면 해당 결과로 드리븐 테이블에 접근되므로 ,

어떤 테이블을 드라이빙 테이블로 설정할지는 성능에 영향을 미침

적은 테이블을 드라이빙 테이블로 선정하는게 좋음

### 중첩 루프 조인

Nested Loop JOIN . NL조인.

드라이빙 테이블 데이터 1건당 드리븐 테이블을 전부 반복 검색.

예를 들어 100행의 학생 테이블, 1000행의 비상연락망 테이블이 있다고 가정하면

```sql
SELECT 학생.학번, 학생.이름, 비상연락망.관계 , 비상연락망.연락처
FROM 학생
JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN(1,100)
```

이와 같이 학번 1,100번 학생들의 정보와 비상연락망 정보를 가져온다고  하면,

학번1을 학번에서 검색(100번) , 해당 학번을 비상연락망 테이블에서 비교(1000건)

1100*2 = 2200건이 수행됨.

학번 열로 인덱스가 생성되었다고 가정하면, 비상연락망 내 해당 학번 데이터만 접근하므로 6회로 감소

(인덱스가 접근 대상인지 판단하는 연산은 고려하지 않음)

인덱스로 테이블에 데이터를 찾아가는 과정에서 랜덤 액세스 발생.

랜덤 엑세스를 줄이기 위해 데이터의 엑세스 범위를 좁히는 방향으로 인덱스 및 조건절 설계.

단, 랜덤 엑세스를 유발하는 인덱스는 기본 키가 아닌 비고유 인덱스의 경우 해당됨. 

기본 키는 클러스터형 인덱스이므로 조회 효율이 높음

### 블록 중첩 루프 조인

BNL 조인.

인덱스가 없는 드리븐 테이블에 대해 매번 전체 데이터를 비효율적으로 검색해야 함.

이러한 효율성을 높이기 위해 

드라이빙 테이블에 조인 버퍼라는 개념을 도입.

![IMG_5082.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/370ae830-428f-4551-8112-115315fb5480/IMG_5082.jpeg)

작동 방식

1. 드라이빙 테이블에서 해당 데이터 검색
2. 검색된 데이터를 조인 버퍼에 가득 채워질때까지 적재
3. 조인 버퍼와 드라이븐 테이블 비교
4. 위의 행동을 반복

조인버퍼의 데이터들과 드라이븐 테이블의 테이블 풀 스캔으로 원하는 데이터를 찾을 수. 있음.

### 배치 키 액세스 조인

Batched Key Access JOIN (BKA JOIN)

중첩 루프 조인은 데이터 접근식 인덱스에 의한 랜덤 엑세스가 발생하므로

액세스할 데이터의 범위가 넓다면 비효율적임.

따라서 접근할 데이터를 미리 예상하고 가져오는 조인 알고리즘인 BKA 조인 등장

BLK의 조인 버퍼 + 드리븐 테이블의 데이터 예측, 정렬된 상태로 담는(Multi Range Read ) 랜덤 버퍼.

미리 예측된 데이터를 가져와서 정렬된 상태에서 랜덤 버퍼에 담음. 드리븐 테이블에 대해. 랜덤 엑세스가 아닌 시퀸셜 엑서스 수행 방식.

 

![IMG_5083.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/51df0e2c-d060-43f0-b7e0-94fdd5faed03/IMG_5083.jpeg)

1. 드라이빙테이블에서 필요 데이터 추출→ 조인버퍼에 적재
2. 드리븐 테이블 인덱스 기반  필요데이터 예측 및 랜덤버퍼 적재. 
3. 조인 조건절로 비교
4. 드리븐테이블 데이터 접근. 결과 조인 및. ㅏㄴ단

### 해시 조인

조인에 참여하는 데이터를 내부적으로 해시값으로 만들어 수행.

내부조인결과는 조인 버퍼에 저장됨.

MySQL에서는 최근부터 지원함. 아직은 핵심적인 조인 알고리즘으로 처리되지 못함.

## 개념적인 튜닝 용어

### 오브젝트 스캔 유형

테이블 스캔과 인덱스 스캔으로 나뉨

테이블 스캔 : 인덱스를 거치지 않고 바로 테이블 데이터 접근

인덱스 스캔 : 인덱스로 테이블 데이터 접근

현업에서 주로 사용하는 방식 :

테이블 스캔 : 테이블 풀 스캔

인덱스 스캔: 인덱스 범위스캔, 인덱스 풀스캔, 인덱스 고유스캔, 인덱스 루스스캔, 인덱스 병합스캔

### 테이블 풀 스캔.

WHERE 절의 조건문을 기준으로 활용할 인덱스가 없거나, 전체 데이터 대비 대량의 데이터가 필요할 때 테이블 풀 스캔 수행. 인덱스를 거치지 않고 테이블 처음부터 끝까지 스캔하는 방식

![IMG_5084.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/8995d02f-1245-4bcb-bd6d-82391e1b6c49/IMG_5084.heic)

### 인덱스 범위 스캔

인덱스를 범위 기준으로 스캔한 뒤, 스캔 결과를 토대로 데이터 탐색

BETWEEN ~ AND 구문이나 <,>, LIKE 구문 비교등으로 사용

좁은 범위 스캔시 효율적.

![IMG_5085.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/30f73d50-3fdd-4fa7-b3f9-571a1490b02e/IMG_5085.heic)

### 인덱스 풀 스캔

인덱스를 처음부터 끝까지 수행하는 방식.

테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL문에서 사용

테이블 풀 스캔보다 성능상 유리. 

![IMG_5086.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/77be38ff-7815-4c17-bb75-4a584a5a0f7d/IMG_5086.heic)

### 인덱스 고유 스캔

기본키나 고유 인덱스로 테이블에 접근하는 방식

인덱스 사용 스캔중 가장 효율적

WHERE 절에 = 조건으로 작성.

![IMG_5087.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/a053d660-0b70-4f90-b1fc-5b4bbc2265c6/IMG_5087.heic)

### 인덱스 루스 스캔

Index Loose Scan

인덱스의 필요한 부분만 골라 스캔하는 방식

보통 GROUP BY , MAX(), MIN() 등의 함수가 포함되면 작동

이미 오름차순으로 정렬된 인덱스에서 최댓값이나 최솟값이 필요한 경우가 해당

![IMG_5088.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/2607349d-44b6-42f7-a4d5-e5af2593d77f/IMG_5088.heic)

### 인덱스 병합 스캔

테이블 내 인덱스들을 통합해서 스캔

WHERE 문 조건절의 열들이 서로 다른 인덱스로 존재하면

옵티마이저가 해당 인덱스들을 모두 활용. (Union, Intersection)

인덱스 접근 시간이 증가되므로 미리 인덱스를 병합하거나 하나의 인덱스만 수행하도록 개선 가능

![IMG_5089.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/2bf91f64-320f-4441-8d41-2de306b2a161/IMG_5089.heic)

### 디스크 접근 방식

데이터를 찾는 방식은 저장된 스토리지의 페이지에 접근으로 이룽어짐.

페이지 : 데이터 검색의 최소단위. 페이지 단위로 R/W 수행 .

시퀀셜 액세스 : 연결된 페이지 순차 탐색

랜덤 액세스 : 무작위 탐색

### 시퀀셜 액세스

테이블 풀 스캔에서 활용됨. 디스크 헤더의 움직임 최소화. 작업 시간 및 리소스 점유 비용 감소

다중 페이지 읽기 방식 (인접 페이지 여러개 읽는) 으로 수행됨

### 랜덤 액세스

다중 페이지 읽기 불가능. 접근 수행시간 오래걸림

따라서 접근 범위를 줄이고 효율적인 인덱스 활용하도록 튜닝 필요.

### 조건 유형

SQL문의 WHERE 절 기준으로 데이터가 저장된 디스크에 접근하게 됨.

필요한 데이터에 엑세스하는 조건문 → 가져온 데이터에서 다시 출력할 데이터 추출.

필요한 데이터를 디스크에서 검색하는 조건이 액세스 조건

디스크에서 가져온 데이터에서 추가 추출이나 가공연산하는 조건이 필터조건

### 액세스 조건

디스크에 있는 데이터에 어떻게 접근하는지. 그 방식

WHERE 절의 조건문으로 필요한 데이터만 골라 가져오는 방식.

테이블에 직접 접근할건지, 인덱스를 통해 접근할 것인지.

옵티마이저는 최적화를 위해 WHERE절의 특정 조건문을 사용하여 소량의 데이터를 가져오고,

인덱스를 통해 시간낭비를 줄이는 조건절을 사용하며,

스토리지 엔진의 데이터에 접근함.

예) 인덱스가 있는 조건문을 먼저 활용하여 접근.

![IMG_5092.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/c6e5023f-cae8-42f3-8e99-9f95c966eba4/IMG_5092.heic)

 

### 필터 조건

액세스 조건을 통해 가져온 데이터를 , 가공하거나 불필요 데이터 제거하는 과정.

필터링된 데이터가 많을수록 비효율적인 SQL문.

필터 조건으로 제거될 데이터면 스토리지 엔진 접근시 같이 제외되는것이 성능적으로 효율적임.

![IMG_5093.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/acc36000-d256-402d-b556-1ea406ceaf8a/7dac604f-6e50-462f-a189-23ce75bfb13f/IMG_5093.heic)

### 응용 용어

### 선택도

테이블 특정 열을 기준으로,

해당 열의 조건절(WHERE절 조건문) 에 따라 선택되는 데이터 비율.

해당 열에 중복되는 데이터가 많으면 선택도가 증가하고, 적으면 감소함.

낮은 선택도가 오히려 대용량 데이터에서는 원하는 데이터를 골라내는 능력임

→낮은 선택도를 가지는 열이 주요 고려대상.

→조건문에서 결과가 많이 나온다→선택도가 높다

계산 방법

데이터에 접근하고자 특정 열에 대한 조건문을 작성하고, 해당 조건문에 포함되는 열의 선택도를 산출.

$$
선택도 = 선택한 데이터 건수 / 전체 데이터 건수
$$

보통 중복이 제거된 데이터의 건수를 활용해서 일반화함

$$
변형된 선택도 = 1 / DISTINCT( COUNT 열명)
$$

### 카디널리티

하나의 데이터 유형으로 정의되는 데이터 행의 개수.

전체 데이터 접근 뒤, 출력될것이라 예상되는 데이터 건수.

→ 전체 행에 대한 특정 열의 중복 수치.

$$
카디널리티 = 전체 데이터 건수 * 선택도
$$

MySQL에서는 중복을 제외한 유일한 데이터값 수로 계산함.

특정 열에 중복된 값이 많다면 카디널리티가 낮음, 

→ 해당 열을 조회하면 데이터를 거르지 못하고 대량의 데이터 출력될것이라 예상됨.

카디널리티는 출력의 정확성과 비례. 중복성과 반비례.

예시) 주민등록번호는 중복성이 0에 가까움. 따라서 카디널리티가 높은 열이자 데이터

성별은 중복성이 매우 높음, 카디널리티 낮음.

### 힌트

데이터를 빨리 찾을수 있게 추가정보를 전달하는 것.

특정 인덱스를 추가함으로써 더 빠르게 데이터를 찾는 방법.

실무에 자주 쓰이는 힌트 목록

| 힌트 | 설명 | 활용도 |
| --- | --- | --- |
| STRAIGHT_JOIN | FROM절에 작성된 테이블 순으로 조인을 유도하는 힌트 | 높음 |
| USE INDEX | 특정 인덱스를 사용하도록 유도하는 힌트 | 높음 |
| FORCE INDEX | 특정 인덱스 사용을 강하게 유도하는 힌트 | 낮음 |
| IGNORE INDEX | 특정 인덱스 사용 금지 힌트 | 중간 |

### 콜레이션

특정 문자셋으로 DB값을 비교하거나 정렬하는 규칙

숫자, 날짜 대소비교처럼 문자 대소비교는 어떻게 하는가?

흔히 쓰이는 콜레이션으로 확인 ( utf8_bin , utf8_general_ci)

bin : A-B-a-b 순

gen_ci : A-a-B-b 순

이러한 콜레이션은 데이터베이스,테이블,열단위까지 설정 가능.

상위 콜레이션을 따라가지만, 하위 콜레이션 세부 설정시 상위 콜레이션 규칙 무시.

### 통계정보

옵티마이저의 기반정보. 

최신성 및 유지관리 필요.

### 히스토그램

테이블의 열값이 어떻게 분포되어있는지 확인하는 통계정보

옵티마이저가 실행 계획을 최적화할때 참고하는 정보임.

특정 열값의 통계정보가 히스토그램으로 수집되지 않았다면

중복이 제거된 열값의 개수(COUNT(DISTINCT 열명)) 으로 대략적인 분포 측정후 계획수립

MySQL에서는 대략적으로 높이균형 히스토그램 사용. - 데이터값을 그룹화, 정해진 버킷 만큼 분리해서 저장
